{"id":"Gpjh","dependencies":[{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\package.json","includedInParent":true,"mtime":1640608262491},{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\package.json","includedInParent":true,"mtime":1640596613181},{"name":"../language/kinds.mjs","loc":{"line":1,"column":21},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\TypeInfo.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\language\\kinds.mjs"},{"name":"../language/ast.mjs","loc":{"line":2,"column":23},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\TypeInfo.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\language\\ast.mjs"},{"name":"../language/visitor.mjs","loc":{"line":3,"column":37},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\TypeInfo.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\language\\visitor.mjs"},{"name":"../type/definition.mjs","loc":{"line":15,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\TypeInfo.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\definition.mjs"},{"name":"../type/introspection.mjs","loc":{"line":20,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\TypeInfo.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\introspection.mjs"},{"name":"./typeFromAST.mjs","loc":{"line":21,"column":28},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\TypeInfo.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\typeFromAST.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeInfo = void 0;\nexports.visitWithTypeInfo = visitWithTypeInfo;\n\nvar _kinds = require(\"../language/kinds.mjs\");\n\nvar _ast = require(\"../language/ast.mjs\");\n\nvar _visitor = require(\"../language/visitor.mjs\");\n\nvar _definition = require(\"../type/definition.mjs\");\n\nvar _introspection = require(\"../type/introspection.mjs\");\n\nvar _typeFromAST = require(\"./typeFromAST.mjs\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nvar TypeInfo = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function TypeInfo(schema,\n  /**\n   * Initial type may be provided in rare cases to facilitate traversals\n   *  beginning somewhere other than documents.\n   */\n  initialType,\n  /** @deprecated will be removed in 17.0.0 */\n  getFieldDefFn) {\n    _classCallCheck(this, TypeInfo);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  _createClass(TypeInfo, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'TypeInfo';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      if (this._typeStack.length > 0) {\n        return this._typeStack[this._typeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getParentType\",\n    value: function getParentType() {\n      if (this._parentTypeStack.length > 0) {\n        return this._parentTypeStack[this._parentTypeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getInputType\",\n    value: function getInputType() {\n      if (this._inputTypeStack.length > 0) {\n        return this._inputTypeStack[this._inputTypeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getParentInputType\",\n    value: function getParentInputType() {\n      if (this._inputTypeStack.length > 1) {\n        return this._inputTypeStack[this._inputTypeStack.length - 2];\n      }\n    }\n  }, {\n    key: \"getFieldDef\",\n    value: function getFieldDef() {\n      if (this._fieldDefStack.length > 0) {\n        return this._fieldDefStack[this._fieldDefStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getDefaultValue\",\n    value: function getDefaultValue() {\n      if (this._defaultValueStack.length > 0) {\n        return this._defaultValueStack[this._defaultValueStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getDirective\",\n    value: function getDirective() {\n      return this._directive;\n    }\n  }, {\n    key: \"getArgument\",\n    value: function getArgument() {\n      return this._argument;\n    }\n  }, {\n    key: \"getEnumValue\",\n    value: function getEnumValue() {\n      return this._enumValue;\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(node) {\n      var schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n      // any assumptions of a valid schema to ensure runtime types are properly\n      // checked before continuing since TypeInfo is used as part of validation\n      // which occurs before guarantees of schema and document validity.\n\n      switch (node.kind) {\n        case _kinds.Kind.SELECTION_SET:\n          {\n            var namedType = (0, _definition.getNamedType)(this.getType());\n\n            this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);\n\n            break;\n          }\n\n        case _kinds.Kind.FIELD:\n          {\n            var parentType = this.getParentType();\n            var fieldDef;\n            var fieldType;\n\n            if (parentType) {\n              fieldDef = this._getFieldDef(schema, parentType, node);\n\n              if (fieldDef) {\n                fieldType = fieldDef.type;\n              }\n            }\n\n            this._fieldDefStack.push(fieldDef);\n\n            this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);\n\n            break;\n          }\n\n        case _kinds.Kind.DIRECTIVE:\n          this._directive = schema.getDirective(node.name.value);\n          break;\n\n        case _kinds.Kind.OPERATION_DEFINITION:\n          {\n            var rootType = schema.getRootType(node.operation);\n\n            this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : undefined);\n\n            break;\n          }\n\n        case _kinds.Kind.INLINE_FRAGMENT:\n        case _kinds.Kind.FRAGMENT_DEFINITION:\n          {\n            var typeConditionAST = node.typeCondition;\n            var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());\n\n            this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);\n\n            break;\n          }\n\n        case _kinds.Kind.VARIABLE_DEFINITION:\n          {\n            var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\n            this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);\n\n            break;\n          }\n\n        case _kinds.Kind.ARGUMENT:\n          {\n            var _this$getDirective;\n\n            var argDef;\n            var argType;\n            var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n            if (fieldOrDirective) {\n              argDef = fieldOrDirective.args.find(function (arg) {\n                return arg.name === node.name.value;\n              });\n\n              if (argDef) {\n                argType = argDef.type;\n              }\n            }\n\n            this._argument = argDef;\n\n            this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n            this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);\n\n            break;\n          }\n\n        case _kinds.Kind.LIST:\n          {\n            var listType = (0, _definition.getNullableType)(this.getInputType());\n            var itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n            this._defaultValueStack.push(undefined);\n\n            this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);\n\n            break;\n          }\n\n        case _kinds.Kind.OBJECT_FIELD:\n          {\n            var objectType = (0, _definition.getNamedType)(this.getInputType());\n            var inputFieldType;\n            var inputField;\n\n            if ((0, _definition.isInputObjectType)(objectType)) {\n              inputField = objectType.getFields()[node.name.value];\n\n              if (inputField) {\n                inputFieldType = inputField.type;\n              }\n            }\n\n            this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n            this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);\n\n            break;\n          }\n\n        case _kinds.Kind.ENUM:\n          {\n            var enumType = (0, _definition.getNamedType)(this.getInputType());\n            var enumValue;\n\n            if ((0, _definition.isEnumType)(enumType)) {\n              enumValue = enumType.getValue(node.value);\n            }\n\n            this._enumValue = enumValue;\n            break;\n          }\n\n        default: // Ignore other nodes\n\n      }\n    }\n  }, {\n    key: \"leave\",\n    value: function leave(node) {\n      switch (node.kind) {\n        case _kinds.Kind.SELECTION_SET:\n          this._parentTypeStack.pop();\n\n          break;\n\n        case _kinds.Kind.FIELD:\n          this._fieldDefStack.pop();\n\n          this._typeStack.pop();\n\n          break;\n\n        case _kinds.Kind.DIRECTIVE:\n          this._directive = null;\n          break;\n\n        case _kinds.Kind.OPERATION_DEFINITION:\n        case _kinds.Kind.INLINE_FRAGMENT:\n        case _kinds.Kind.FRAGMENT_DEFINITION:\n          this._typeStack.pop();\n\n          break;\n\n        case _kinds.Kind.VARIABLE_DEFINITION:\n          this._inputTypeStack.pop();\n\n          break;\n\n        case _kinds.Kind.ARGUMENT:\n          this._argument = null;\n\n          this._defaultValueStack.pop();\n\n          this._inputTypeStack.pop();\n\n          break;\n\n        case _kinds.Kind.LIST:\n        case _kinds.Kind.OBJECT_FIELD:\n          this._defaultValueStack.pop();\n\n          this._inputTypeStack.pop();\n\n          break;\n\n        case _kinds.Kind.ENUM:\n          this._enumValue = null;\n          break;\n\n        default: // Ignore other nodes\n\n      }\n    }\n  }]);\n\n  return TypeInfo;\n}(Symbol.toStringTag);\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\n\nexports.TypeInfo = TypeInfo;\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var node = args[0];\n      typeInfo.enter(node);\n      var fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;\n\n      if (fn) {\n        var result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if ((0, _ast.isNode)(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var node = args[0];\n      var fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}"},"sourceMaps":null,"error":null,"hash":"d7b54baf1778db567234c65fb5032698","cacheData":{"env":{}}}