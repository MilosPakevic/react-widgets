{"id":"KnZi","dependencies":[{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\package.json","includedInParent":true,"mtime":1640608262491},{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\package.json","includedInParent":true,"mtime":1640596614123},{"name":"tslib","loc":{"line":1,"column":25},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\readFromStore.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\tslib\\tslib.es6.js"},{"name":"../../utilities/globals/index.js","loc":{"line":2,"column":26},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\readFromStore.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\utilities\\globals\\index.js"},{"name":"optimism","loc":{"line":3,"column":21},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\readFromStore.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\optimism\\lib\\bundle.esm.js"},{"name":"../../utilities/index.js","loc":{"line":4,"column":311},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\readFromStore.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\utilities\\index.js"},{"name":"./entityStore.js","loc":{"line":5,"column":70},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\readFromStore.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\entityStore.js"},{"name":"./helpers.js","loc":{"line":6,"column":66},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\readFromStore.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\helpers.js"},{"name":"../core/types/common.js","loc":{"line":7,"column":34},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\readFromStore.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\core\\types\\common.js"},{"name":"./object-canon.js","loc":{"line":8,"column":48},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\readFromStore.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\inmemory\\object-canon.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StoreReader = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _index = require(\"../../utilities/globals/index.js\");\n\nvar _optimism = require(\"optimism\");\n\nvar _index2 = require(\"../../utilities/index.js\");\n\nvar _entityStore = require(\"./entityStore.js\");\n\nvar _helpers = require(\"./helpers.js\");\n\nvar _common = require(\"../core/types/common.js\");\n\nvar _objectCanon = require(\"./object-canon.js\");\n\n;\n\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context, options.context.canonizeResults];\n}\n\nvar StoreReader = function () {\n  function StoreReader(config) {\n    var _this = this;\n\n    this.knownResults = new (_index2.canUseWeakMap ? WeakMap : Map)();\n    this.config = (0, _index2.compact)(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: (0, _helpers.shouldCanonizeResults)(config)\n    });\n    this.canon = config.canon || new _objectCanon.ObjectCanon();\n    this.executeSelectionSet = (0, _optimism.wrap)(function (options) {\n      var _a;\n\n      var canonizeResults = options.context.canonizeResults;\n      var peekArgs = execSelectionSetKeyArgs(options);\n      peekArgs[3] = !canonizeResults;\n\n      var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n\n      if (other) {\n        if (canonizeResults) {\n          return (0, _tslib.__assign)((0, _tslib.__assign)({}, other), {\n            result: _this.canon.admit(other.result)\n          });\n        }\n\n        return other;\n      }\n\n      (0, _entityStore.maybeDependOnExistenceOfEntity)(options.context.store, options.enclosingRef.__ref);\n      return _this.execSelectionSetImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      keyArgs: execSelectionSetKeyArgs,\n      makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n        if ((0, _entityStore.supportsResultCaching)(context.store)) {\n          return context.store.makeCacheKey(selectionSet, (0, _index2.isReference)(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n        }\n      }\n    });\n    this.executeSubSelectedArray = (0, _optimism.wrap)(function (options) {\n      (0, _entityStore.maybeDependOnExistenceOfEntity)(options.context.store, options.enclosingRef.__ref);\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n            array = _a.array,\n            context = _a.context;\n\n        if ((0, _entityStore.supportsResultCaching)(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n\n  StoreReader.prototype.resetCanon = function () {\n    this.canon = new _objectCanon.ObjectCanon();\n  };\n\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n        query = _a.query,\n        _b = _a.rootId,\n        rootId = _b === void 0 ? 'ROOT_QUERY' : _b,\n        variables = _a.variables,\n        _c = _a.returnPartialData,\n        returnPartialData = _c === void 0 ? true : _c,\n        _d = _a.canonizeResults,\n        canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n    var policies = this.config.cache.policies;\n    variables = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _index2.getDefaultValues)((0, _index2.getQueryDefinition)(query))), variables);\n    var rootRef = (0, _index2.makeReference)(rootId);\n    var merger = new _index2.DeepMerger();\n    var execResult = this.executeSelectionSet({\n      selectionSet: (0, _index2.getMainDefinition)(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: (0, _objectCanon.canonicalStringify)(variables),\n        canonizeResults: canonizeResults,\n        fragmentMap: (0, _index2.createFragmentMap)((0, _index2.getFragmentDefinitions)(query)),\n        merge: function (a, b) {\n          return merger.merge(a, b);\n        }\n      }\n    });\n    var missing;\n\n    if (execResult.missing) {\n      missing = [new _common.MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];\n\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing: missing\n    };\n  };\n\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if ((0, _entityStore.supportsResultCaching)(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));\n\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n\n    var selectionSet = _a.selectionSet,\n        objectOrReference = _a.objectOrReference,\n        enclosingRef = _a.enclosingRef,\n        context = _a.context;\n\n    if ((0, _index2.isReference)(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n      };\n    }\n\n    var variables = context.variables,\n        policies = context.policies,\n        store = context.store;\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n    var result = {};\n    var missing;\n\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      result = {\n        __typename: typename\n      };\n    }\n\n    function handleMissing(result, resultName) {\n      var _a;\n\n      if (result.missing) {\n        missing = context.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n      }\n\n      return result.result;\n    }\n\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a, _b;\n\n      if (!(0, _index2.shouldInclude)(selection, variables)) return;\n\n      if ((0, _index2.isField)(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = (0, _index2.resultKeyNameFromField)(selection);\n\n        if (fieldValue === void 0) {\n          if (!_index2.addTypenameToDocument.added(selection)) {\n            missing = context.merge(missing, (_a = {}, _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat((0, _index2.isReference)(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2)), _a));\n          }\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(_this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            enclosingRef: enclosingRef,\n            context: context\n          }), resultName);\n        } else if (!selection.selectionSet) {\n          if (context.canonizeResults) {\n            fieldValue = _this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: (0, _index2.isReference)(fieldValue) ? fieldValue : enclosingRef,\n            context: context\n          }), resultName);\n        }\n\n        if (fieldValue !== void 0) {\n          result = context.merge(result, (_b = {}, _b[resultName] = fieldValue, _b));\n        }\n      } else {\n        var fragment = (0, _index2.getFragmentFromSelection)(selection, context.fragmentMap);\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    var finalResult = {\n      result: result,\n      missing: missing\n    };\n    var frozen = context.canonizeResults ? this.canon.admit(finalResult) : (0, _index2.maybeDeepFreeze)(finalResult);\n\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  };\n\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n\n    var field = _a.field,\n        array = _a.array,\n        enclosingRef = _a.enclosingRef,\n        context = _a.context;\n    var missing;\n\n    function handleMissing(childResult, i) {\n      var _a;\n\n      if (childResult.missing) {\n        missing = context.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n      }\n\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map(function (item, i) {\n      if (item === null) {\n        return null;\n      }\n\n      if (Array.isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          enclosingRef: enclosingRef,\n          context: context\n        }), i);\n      }\n\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: (0, _index2.isReference)(item) ? item : enclosingRef,\n          context: context\n        }), i);\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing: missing\n    };\n  };\n\n  return StoreReader;\n}();\n\nexports.StoreReader = StoreReader;\n\nfunction firstMissing(tree) {\n  try {\n    JSON.stringify(tree, function (_, value) {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\n\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if ((0, _index2.isNonNullObject)(value)) {\n        __DEV__ ? (0, _index.invariant)(!(0, _index2.isReference)(value), \"Missing selection set for object of type \".concat((0, _helpers.getTypenameFromStoreObject)(store, value), \" returned for query field \").concat(field.name.value)) : (0, _index.invariant)(!(0, _index2.isReference)(value), 5);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}"},"sourceMaps":null,"error":null,"hash":"108f739e2bd2322b8e16e97c1e60edbc","cacheData":{"env":{}}}