{"id":"WsyK","dependencies":[{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\package.json","includedInParent":true,"mtime":1640608262491},{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\package.json","includedInParent":true,"mtime":1640596613181},{"name":"../../jsutils/didYouMean.mjs","loc":{"line":1,"column":27},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\validation\\rules\\KnownTypeNamesRule.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\didYouMean.mjs"},{"name":"../../jsutils/suggestionList.mjs","loc":{"line":2,"column":31},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\validation\\rules\\KnownTypeNamesRule.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\suggestionList.mjs"},{"name":"../../error/GraphQLError.mjs","loc":{"line":3,"column":29},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\validation\\rules\\KnownTypeNamesRule.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\error\\GraphQLError.mjs"},{"name":"../../language/predicates.mjs","loc":{"line":8,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\validation\\rules\\KnownTypeNamesRule.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\language\\predicates.mjs"},{"name":"../../type/scalars.mjs","loc":{"line":9,"column":37},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\validation\\rules\\KnownTypeNamesRule.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\scalars.mjs"},{"name":"../../type/introspection.mjs","loc":{"line":10,"column":35},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\validation\\rules\\KnownTypeNamesRule.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\introspection.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KnownTypeNamesRule = KnownTypeNamesRule;\n\nvar _didYouMean = require(\"../../jsutils/didYouMean.mjs\");\n\nvar _suggestionList = require(\"../../jsutils/suggestionList.mjs\");\n\nvar _GraphQLError = require(\"../../error/GraphQLError.mjs\");\n\nvar _predicates = require(\"../../language/predicates.mjs\");\n\nvar _scalars = require(\"../../type/scalars.mjs\");\n\nvar _introspection = require(\"../../type/introspection.mjs\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nfunction KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  var _iterator = _createForOfIteratorHelper(context.getDocument().definitions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var def = _step.value;\n\n      if ((0, _predicates.isTypeDefinitionNode)(def)) {\n        definedTypes[def.name.value] = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var typeNames = [].concat(_toConsumableArray(Object.keys(existingTypesMap)), _toConsumableArray(Object.keys(definedTypes)));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = (0, _suggestionList.suggestionList)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new _GraphQLError.GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + (0, _didYouMean.didYouMean)(suggestedTypes), node));\n      }\n    }\n  };\n}\n\nvar standardTypeNames = [].concat(_toConsumableArray(_scalars.specifiedScalarTypes), _toConsumableArray(_introspection.introspectionTypes)).map(function (type) {\n  return type.name;\n});\n\nfunction isSDLNode(value) {\n  return 'kind' in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));\n}"},"sourceMaps":null,"error":null,"hash":"959f6f18ccd0ee124c17a0594b1f7c60","cacheData":{"env":{}}}