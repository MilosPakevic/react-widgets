{"id":"tGrc","dependencies":[{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\package.json","includedInParent":true,"mtime":1640608262491},{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\package.json","includedInParent":true,"mtime":1640596613181},{"name":"../jsutils/keyMap.mjs","loc":{"line":1,"column":23},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\keyMap.mjs"},{"name":"../jsutils/inspect.mjs","loc":{"line":2,"column":24},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\inspect.mjs"},{"name":"../jsutils/invariant.mjs","loc":{"line":3,"column":26},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\invariant.mjs"},{"name":"../jsutils/naturalCompare.mjs","loc":{"line":4,"column":31},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\naturalCompare.mjs"},{"name":"../language/printer.mjs","loc":{"line":5,"column":22},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\language\\printer.mjs"},{"name":"../language/visitor.mjs","loc":{"line":6,"column":22},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\language\\visitor.mjs"},{"name":"../type/scalars.mjs","loc":{"line":7,"column":38},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\scalars.mjs"},{"name":"../type/definition.mjs","loc":{"line":20,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\definition.mjs"},{"name":"./astFromValue.mjs","loc":{"line":21,"column":29},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\findBreakingChanges.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\astFromValue.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DangerousChangeType = exports.BreakingChangeType = void 0;\nexports.findBreakingChanges = findBreakingChanges;\nexports.findDangerousChanges = findDangerousChanges;\n\nvar _keyMap = require(\"../jsutils/keyMap.mjs\");\n\nvar _inspect = require(\"../jsutils/inspect.mjs\");\n\nvar _invariant = require(\"../jsutils/invariant.mjs\");\n\nvar _naturalCompare = require(\"../jsutils/naturalCompare.mjs\");\n\nvar _printer = require(\"../language/printer.mjs\");\n\nvar _visitor = require(\"../language/visitor.mjs\");\n\nvar _scalars = require(\"../type/scalars.mjs\");\n\nvar _definition = require(\"../type/definition.mjs\");\n\nvar _astFromValue = require(\"./astFromValue.mjs\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar BreakingChangeType;\nexports.BreakingChangeType = BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] = 'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] = 'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] = 'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] = 'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] = 'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}));\n\nvar DangerousChangeType;\nexports.DangerousChangeType = DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] = 'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] = 'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {}));\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\n\n\nfunction findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in BreakingChangeType;\n  });\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\n\nfunction findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(function (change) {\n    return change.type in DangerousChangeType;\n  });\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [].concat(_toConsumableArray(findTypeChanges(oldSchema, newSchema)), _toConsumableArray(findDirectiveChanges(oldSchema, newSchema)));\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n\n  var _iterator = _createForOfIteratorHelper(directivesDiff.removed),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var oldDirective = _step.value;\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REMOVED,\n        description: \"\".concat(oldDirective.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(directivesDiff.persisted),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          _oldDirective = _step2$value[0],\n          newDirective = _step2$value[1];\n\n      var argsDiff = diff(_oldDirective.args, newDirective.args);\n\n      var _iterator3 = _createForOfIteratorHelper(argsDiff.added),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var newArg = _step3.value;\n\n          if ((0, _definition.isRequiredArgument)(newArg)) {\n            schemaChanges.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(newArg.name, \" on directive \").concat(_oldDirective.name, \" was added.\")\n            });\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(argsDiff.removed),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var oldArg = _step4.value;\n          schemaChanges.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(oldArg.name, \" was removed from \").concat(_oldDirective.name, \".\")\n          });\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n          description: \"Repeatable flag was removed from \".concat(_oldDirective.name, \".\")\n        });\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(_oldDirective.locations),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var location = _step5.value;\n\n          if (!newDirective.locations.includes(location)) {\n            schemaChanges.push({\n              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n              description: \"\".concat(location, \" was removed from \").concat(_oldDirective.name, \".\")\n            });\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  var schemaChanges = [];\n  var typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));\n\n  var _iterator6 = _createForOfIteratorHelper(typesDiff.removed),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var oldType = _step6.value;\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: (0, _scalars.isSpecifiedScalarType)(oldType) ? \"Standard scalar \".concat(oldType.name, \" was removed because it is not referenced anymore.\") : \"\".concat(oldType.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  var _iterator7 = _createForOfIteratorHelper(typesDiff.persisted),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n          _oldType = _step7$value[0],\n          newType = _step7$value[1];\n\n      if ((0, _definition.isEnumType)(_oldType) && (0, _definition.isEnumType)(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findEnumTypeChanges(_oldType, newType)));\n      } else if ((0, _definition.isUnionType)(_oldType) && (0, _definition.isUnionType)(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findUnionTypeChanges(_oldType, newType)));\n      } else if ((0, _definition.isInputObjectType)(_oldType) && (0, _definition.isInputObjectType)(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findInputObjectTypeChanges(_oldType, newType)));\n      } else if ((0, _definition.isObjectType)(_oldType) && (0, _definition.isObjectType)(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findFieldChanges(_oldType, newType)).concat(_toConsumableArray(findImplementedInterfacesChanges(_oldType, newType))));\n      } else if ((0, _definition.isInterfaceType)(_oldType) && (0, _definition.isInterfaceType)(newType)) {\n        schemaChanges.push.apply(schemaChanges, _toConsumableArray(findFieldChanges(_oldType, newType)).concat(_toConsumableArray(findImplementedInterfacesChanges(_oldType, newType))));\n      } else if (_oldType.constructor !== newType.constructor) {\n        schemaChanges.push({\n          type: BreakingChangeType.TYPE_CHANGED_KIND,\n          description: \"\".concat(_oldType.name, \" changed from \") + \"\".concat(typeKindName(_oldType), \" to \").concat(typeKindName(newType), \".\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n\n  var _iterator8 = _createForOfIteratorHelper(fieldsDiff.added),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var newField = _step8.value;\n\n      if ((0, _definition.isRequiredInputField)(newField)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n          description: \"A required field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n        });\n      } else {\n        schemaChanges.push({\n          type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n          description: \"An optional field \".concat(newField.name, \" on input type \").concat(oldType.name, \" was added.\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  var _iterator9 = _createForOfIteratorHelper(fieldsDiff.removed),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var oldField = _step9.value;\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_REMOVED,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  var _iterator10 = _createForOfIteratorHelper(fieldsDiff.persisted),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var _step10$value = _slicedToArray(_step10.value, 2),\n          _oldField = _step10$value[0],\n          _newField = _step10$value[1];\n\n      var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);\n\n      if (!isSafe) {\n        schemaChanges.push({\n          type: BreakingChangeType.FIELD_CHANGED_KIND,\n          description: \"\".concat(oldType.name, \".\").concat(_oldField.name, \" changed type from \") + \"\".concat(String(_oldField.type), \" to \").concat(String(_newField.type), \".\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  var _iterator11 = _createForOfIteratorHelper(possibleTypesDiff.added),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var newPossibleType = _step11.value;\n      schemaChanges.push({\n        type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n        description: \"\".concat(newPossibleType.name, \" was added to union type \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  var _iterator12 = _createForOfIteratorHelper(possibleTypesDiff.removed),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var oldPossibleType = _step12.value;\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n        description: \"\".concat(oldPossibleType.name, \" was removed from union type \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  var schemaChanges = [];\n  var valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  var _iterator13 = _createForOfIteratorHelper(valuesDiff.added),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var newValue = _step13.value;\n      schemaChanges.push({\n        type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n        description: \"\".concat(newValue.name, \" was added to enum type \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  var _iterator14 = _createForOfIteratorHelper(valuesDiff.removed),\n      _step14;\n\n  try {\n    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n      var oldValue = _step14.value;\n      schemaChanges.push({\n        type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n        description: \"\".concat(oldValue.name, \" was removed from enum type \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator14.e(err);\n  } finally {\n    _iterator14.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  var schemaChanges = [];\n  var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  var _iterator15 = _createForOfIteratorHelper(interfacesDiff.added),\n      _step15;\n\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var newInterface = _step15.value;\n      schemaChanges.push({\n        type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n        description: \"\".concat(newInterface.name, \" added to interfaces implemented by \").concat(oldType.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n\n  var _iterator16 = _createForOfIteratorHelper(interfacesDiff.removed),\n      _step16;\n\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var oldInterface = _step16.value;\n      schemaChanges.push({\n        type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n        description: \"\".concat(oldType.name, \" no longer implements interface \").concat(oldInterface.name, \".\")\n      });\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  var schemaChanges = [];\n  var fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n\n  var _iterator17 = _createForOfIteratorHelper(fieldsDiff.removed),\n      _step17;\n\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var oldField = _step17.value;\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_REMOVED,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n\n  var _iterator18 = _createForOfIteratorHelper(fieldsDiff.persisted),\n      _step18;\n\n  try {\n    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n      var _step18$value = _slicedToArray(_step18.value, 2),\n          _oldField2 = _step18$value[0],\n          newField = _step18$value[1];\n\n      schemaChanges.push.apply(schemaChanges, _toConsumableArray(findArgChanges(oldType, _oldField2, newField)));\n      var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);\n\n      if (!isSafe) {\n        schemaChanges.push({\n          type: BreakingChangeType.FIELD_CHANGED_KIND,\n          description: \"\".concat(oldType.name, \".\").concat(_oldField2.name, \" changed type from \") + \"\".concat(String(_oldField2.type), \" to \").concat(String(newField.type), \".\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator18.e(err);\n  } finally {\n    _iterator18.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  var schemaChanges = [];\n  var argsDiff = diff(oldField.args, newField.args);\n\n  var _iterator19 = _createForOfIteratorHelper(argsDiff.removed),\n      _step19;\n\n  try {\n    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n      var oldArg = _step19.value;\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_REMOVED,\n        description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(oldArg.name, \" was removed.\")\n      });\n    }\n  } catch (err) {\n    _iterator19.e(err);\n  } finally {\n    _iterator19.f();\n  }\n\n  var _iterator20 = _createForOfIteratorHelper(argsDiff.persisted),\n      _step20;\n\n  try {\n    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n      var _step20$value = _slicedToArray(_step20.value, 2),\n          _oldArg = _step20$value[0],\n          newArg = _step20$value[1];\n\n      var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);\n\n      if (!isSafe) {\n        schemaChanges.push({\n          type: BreakingChangeType.ARG_CHANGED_KIND,\n          description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed type from \") + \"\".concat(String(_oldArg.type), \" to \").concat(String(newArg.type), \".\")\n        });\n      } else if (_oldArg.defaultValue !== undefined) {\n        if (newArg.defaultValue === undefined) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" defaultValue was removed.\")\n          });\n        } else {\n          // Since we looking only for client's observable changes we should\n          // compare default values in the same representation as they are\n          // represented inside introspection.\n          var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);\n          var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n          if (oldValueStr !== newValueStr) {\n            schemaChanges.push({\n              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n              description: \"\".concat(oldType.name, \".\").concat(oldField.name, \" arg \").concat(_oldArg.name, \" has changed defaultValue from \").concat(oldValueStr, \" to \").concat(newValueStr, \".\")\n            });\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator20.e(err);\n  } finally {\n    _iterator20.f();\n  }\n\n  var _iterator21 = _createForOfIteratorHelper(argsDiff.added),\n      _step21;\n\n  try {\n    for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n      var _newArg = _step21.value;\n\n      if ((0, _definition.isRequiredArgument)(_newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_ARG_ADDED,\n          description: \"A required arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n        });\n      } else {\n        schemaChanges.push({\n          type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n          description: \"An optional arg \".concat(_newArg.name, \" on \").concat(oldType.name, \".\").concat(oldField.name, \" was added.\")\n        });\n      }\n    }\n  } catch (err) {\n    _iterator21.e(err);\n  } finally {\n    _iterator21.f();\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return (// if they're both named types, see if their names are equivalent\n    (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n    (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n\n  return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return 'a Scalar type';\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return 'an Object type';\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return 'an Interface type';\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return 'a Union type';\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return 'an Enum type';\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n\n  false || (0, _invariant.invariant)(false, 'Unexpected type: ' + (0, _inspect.inspect)(type));\n}\n\nfunction stringifyValue(value, type) {\n  var ast = (0, _astFromValue.astFromValue)(value, type);\n  ast != null || (0, _invariant.invariant)(false);\n  var sortedAST = (0, _visitor.visit)(ast, {\n    ObjectValue: function ObjectValue(objectNode) {\n      // Make a copy since sort mutates array\n      var fields = _toConsumableArray(objectNode.fields);\n\n      fields.sort(function (fieldA, fieldB) {\n        return (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value);\n      });\n      return _objectSpread(_objectSpread({}, objectNode), {}, {\n        fields: fields\n      });\n    }\n  });\n  return (0, _printer.print)(sortedAST);\n}\n\nfunction diff(oldArray, newArray) {\n  var added = [];\n  var removed = [];\n  var persisted = [];\n  var oldMap = (0, _keyMap.keyMap)(oldArray, function (_ref) {\n    var name = _ref.name;\n    return name;\n  });\n  var newMap = (0, _keyMap.keyMap)(newArray, function (_ref2) {\n    var name = _ref2.name;\n    return name;\n  });\n\n  var _iterator22 = _createForOfIteratorHelper(oldArray),\n      _step22;\n\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var oldItem = _step22.value;\n      var newItem = newMap[oldItem.name];\n\n      if (newItem === undefined) {\n        removed.push(oldItem);\n      } else {\n        persisted.push([oldItem, newItem]);\n      }\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n\n  var _iterator23 = _createForOfIteratorHelper(newArray),\n      _step23;\n\n  try {\n    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n      var _newItem = _step23.value;\n\n      if (oldMap[_newItem.name] === undefined) {\n        added.push(_newItem);\n      }\n    }\n  } catch (err) {\n    _iterator23.e(err);\n  } finally {\n    _iterator23.f();\n  }\n\n  return {\n    added: added,\n    persisted: persisted,\n    removed: removed\n  };\n}"},"sourceMaps":null,"error":null,"hash":"84a6608072bdefaac2337d01c2e93825","cacheData":{"env":{}}}