{"id":"rNY2","dependencies":[{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\package.json","includedInParent":true,"mtime":1640608262491},{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\core\\package.json","includedInParent":true,"mtime":1640596614132},{"name":"tslib","loc":{"line":1,"column":49},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\core\\LocalState.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\tslib\\tslib.es6.js"},{"name":"../utilities/globals/index.js","loc":{"line":2,"column":26},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\core\\LocalState.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\utilities\\globals\\index.js"},{"name":"graphql","loc":{"line":3,"column":30},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\core\\LocalState.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\index.mjs"},{"name":"../utilities/index.js","loc":{"line":4,"column":270},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\core\\LocalState.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\utilities\\index.js"},{"name":"../cache/index.js","loc":{"line":5,"column":26},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\core\\LocalState.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\cache\\index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LocalState = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _index = require(\"../utilities/globals/index.js\");\n\nvar _graphql = require(\"graphql\");\n\nvar _index2 = require(\"../utilities/index.js\");\n\nvar _index3 = require(\"../cache/index.js\");\n\nvar LocalState = function () {\n  function LocalState(_a) {\n    var cache = _a.cache,\n        client = _a.client,\n        resolvers = _a.resolvers,\n        fragmentMatcher = _a.fragmentMatcher;\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  LocalState.prototype.addResolvers = function (resolvers) {\n    var _this = this;\n\n    this.resolvers = this.resolvers || {};\n\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(function (resolverGroup) {\n        _this.resolvers = (0, _index2.mergeDeep)(_this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = (0, _index2.mergeDeep)(this.resolvers, resolvers);\n    }\n  };\n\n  LocalState.prototype.setResolvers = function (resolvers) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  };\n\n  LocalState.prototype.getResolvers = function () {\n    return this.resolvers || {};\n  };\n\n  LocalState.prototype.runResolvers = function (_a) {\n    var document = _a.document,\n        remoteResult = _a.remoteResult,\n        context = _a.context,\n        variables = _a.variables,\n        _b = _a.onlyRunForcedResolvers,\n        onlyRunForcedResolvers = _b === void 0 ? false : _b;\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      return (0, _tslib.__generator)(this, function (_c) {\n        if (document) {\n          return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {\n            return (0, _tslib.__assign)((0, _tslib.__assign)({}, remoteResult), {\n              data: localResult.result\n            });\n          })];\n        }\n\n        return [2, remoteResult];\n      });\n    });\n  };\n\n  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  };\n\n  LocalState.prototype.getFragmentMatcher = function () {\n    return this.fragmentMatcher;\n  };\n\n  LocalState.prototype.clientQuery = function (document) {\n    if ((0, _index2.hasDirectives)(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n\n    return null;\n  };\n\n  LocalState.prototype.serverQuery = function (document) {\n    return (0, _index2.removeClientSetsFromDocument)(document);\n  };\n\n  LocalState.prototype.prepareContext = function (context) {\n    var cache = this.cache;\n    return (0, _tslib.__assign)((0, _tslib.__assign)({}, context), {\n      cache: cache,\n      getCacheKey: function (obj) {\n        return cache.identify(obj);\n      }\n    });\n  };\n\n  LocalState.prototype.addExportedVariables = function (document, variables, context) {\n    if (variables === void 0) {\n      variables = {};\n    }\n\n    if (context === void 0) {\n      context = {};\n    }\n\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      return (0, _tslib.__generator)(this, function (_a) {\n        if (document) {\n          return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {\n            return (0, _tslib.__assign)((0, _tslib.__assign)({}, variables), data.exportedVariables);\n          })];\n        }\n\n        return [2, (0, _tslib.__assign)({}, variables)];\n      });\n    });\n  };\n\n  LocalState.prototype.shouldForceResolvers = function (document) {\n    var forceResolvers = false;\n    (0, _graphql.visit)(document, {\n      Directive: {\n        enter: function (node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(function (arg) {\n              return arg.name.value === 'always' && arg.value.kind === 'BooleanValue' && arg.value.value === true;\n            });\n\n            if (forceResolvers) {\n              return _graphql.BREAK;\n            }\n          }\n        }\n      }\n    });\n    return forceResolvers;\n  };\n\n  LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n    return this.cache.diff({\n      query: (0, _index2.buildQueryFromSelectionSet)(document),\n      variables: variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n  };\n\n  LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    if (variables === void 0) {\n      variables = {};\n    }\n\n    if (fragmentMatcher === void 0) {\n      fragmentMatcher = function () {\n        return true;\n      };\n    }\n\n    if (onlyRunForcedResolvers === void 0) {\n      onlyRunForcedResolvers = false;\n    }\n\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;\n\n      return (0, _tslib.__generator)(this, function (_b) {\n        mainDefinition = (0, _index2.getMainDefinition)(document);\n        fragments = (0, _index2.getFragmentDefinitions)(document);\n        fragmentMap = (0, _index2.createFragmentMap)(fragments);\n        definitionOperation = mainDefinition.operation;\n        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : 'Query';\n        _a = this, cache = _a.cache, client = _a.client;\n        execContext = {\n          fragmentMap: fragmentMap,\n          context: (0, _tslib.__assign)((0, _tslib.__assign)({}, context), {\n            cache: cache,\n            client: client\n          }),\n          variables: variables,\n          fragmentMatcher: fragmentMatcher,\n          defaultOperationType: defaultOperationType,\n          exportedVariables: {},\n          onlyRunForcedResolvers: onlyRunForcedResolvers\n        };\n        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) {\n          return {\n            result: result,\n            exportedVariables: execContext.exportedVariables\n          };\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var fragmentMap, context, variables, resultsToMerge, execute;\n\n      var _this = this;\n\n      return (0, _tslib.__generator)(this, function (_a) {\n        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n        resultsToMerge = [rootValue];\n\n        execute = function (selection) {\n          return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {\n            var fragment, typeCondition;\n            return (0, _tslib.__generator)(this, function (_a) {\n              if (!(0, _index2.shouldInclude)(selection, variables)) {\n                return [2];\n              }\n\n              if ((0, _index2.isField)(selection)) {\n                return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {\n                  var _a;\n\n                  if (typeof fieldResult !== 'undefined') {\n                    resultsToMerge.push((_a = {}, _a[(0, _index2.resultKeyNameFromField)(selection)] = fieldResult, _a));\n                  }\n                })];\n              }\n\n              if ((0, _index2.isInlineFragment)(selection)) {\n                fragment = selection;\n              } else {\n                fragment = fragmentMap[selection.name.value];\n                __DEV__ ? (0, _index.invariant)(fragment, \"No fragment named \".concat(selection.name.value)) : (0, _index.invariant)(fragment, 9);\n              }\n\n              if (fragment && fragment.typeCondition) {\n                typeCondition = fragment.typeCondition.name.value;\n\n                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {\n                    resultsToMerge.push(fragmentResult);\n                  })];\n                }\n              }\n\n              return [2];\n            });\n          });\n        };\n\n        return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {\n          return (0, _index2.mergeDeepArray)(resultsToMerge);\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveField = function (field, rootValue, execContext) {\n    return (0, _tslib.__awaiter)(this, void 0, void 0, function () {\n      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n\n      var _this = this;\n\n      return (0, _tslib.__generator)(this, function (_a) {\n        variables = execContext.variables;\n        fieldName = field.name.value;\n        aliasedFieldName = (0, _index2.resultKeyNameFromField)(field);\n        aliasUsed = fieldName !== aliasedFieldName;\n        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n        resultPromise = Promise.resolve(defaultResult);\n\n        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n          resolverType = rootValue.__typename || execContext.defaultOperationType;\n          resolverMap = this.resolvers && this.resolvers[resolverType];\n\n          if (resolverMap) {\n            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n\n            if (resolve) {\n              resultPromise = Promise.resolve(_index3.cacheSlot.withValue(this.cache, resolve, [rootValue, (0, _index2.argumentsObjectFromField)(field, variables), execContext.context, {\n                field: field,\n                fragmentMap: execContext.fragmentMap\n              }]));\n            }\n          }\n        }\n\n        return [2, resultPromise.then(function (result) {\n          if (result === void 0) {\n            result = defaultResult;\n          }\n\n          if (field.directives) {\n            field.directives.forEach(function (directive) {\n              if (directive.name.value === 'export' && directive.arguments) {\n                directive.arguments.forEach(function (arg) {\n                  if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                    execContext.exportedVariables[arg.value.value] = result;\n                  }\n                });\n              }\n            });\n          }\n\n          if (!field.selectionSet) {\n            return result;\n          }\n\n          if (result == null) {\n            return result;\n          }\n\n          if (Array.isArray(result)) {\n            return _this.resolveSubSelectedArray(field, result, execContext);\n          }\n\n          if (field.selectionSet) {\n            return _this.resolveSelectionSet(field.selectionSet, result, execContext);\n          }\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {\n    var _this = this;\n\n    return Promise.all(result.map(function (item) {\n      if (item === null) {\n        return null;\n      }\n\n      if (Array.isArray(item)) {\n        return _this.resolveSubSelectedArray(field, item, execContext);\n      }\n\n      if (field.selectionSet) {\n        return _this.resolveSelectionSet(field.selectionSet, item, execContext);\n      }\n    }));\n  };\n\n  return LocalState;\n}();\n\nexports.LocalState = LocalState;"},"sourceMaps":null,"error":null,"hash":"f39c458a32c0cd01a8fe1a5d17eb35ee","cacheData":{"env":{}}}