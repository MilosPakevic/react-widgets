{"id":"VTot","dependencies":[{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\package.json","includedInParent":true,"mtime":1640608262491},{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\package.json","includedInParent":true,"mtime":1640596613181},{"name":"../jsutils/keyMap.mjs","loc":{"line":1,"column":23},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\keyMap.mjs"},{"name":"../jsutils/inspect.mjs","loc":{"line":2,"column":24},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\inspect.mjs"},{"name":"../jsutils/mapValue.mjs","loc":{"line":3,"column":25},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\mapValue.mjs"},{"name":"../jsutils/invariant.mjs","loc":{"line":4,"column":26},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\invariant.mjs"},{"name":"../jsutils/devAssert.mjs","loc":{"line":5,"column":26},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\jsutils\\devAssert.mjs"},{"name":"../language/kinds.mjs","loc":{"line":6,"column":21},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\language\\kinds.mjs"},{"name":"../language/predicates.mjs","loc":{"line":10,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\language\\predicates.mjs"},{"name":"../validation/validate.mjs","loc":{"line":11,"column":40},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\validation\\validate.mjs"},{"name":"../execution/values.mjs","loc":{"line":12,"column":35},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\execution\\values.mjs"},{"name":"../type/schema.mjs","loc":{"line":13,"column":44},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\schema.mjs"},{"name":"../type/scalars.mjs","loc":{"line":17,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\scalars.mjs"},{"name":"../type/introspection.mjs","loc":{"line":21,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\introspection.mjs"},{"name":"../type/directives.mjs","loc":{"line":26,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\directives.mjs"},{"name":"../type/definition.mjs","loc":{"line":44,"column":7},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\type\\definition.mjs"},{"name":"./valueFromAST.mjs","loc":{"line":45,"column":29},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\extendSchema.mjs","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\graphql\\utilities\\valueFromAST.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSchema = extendSchema;\nexports.extendSchemaImpl = extendSchemaImpl;\n\nvar _keyMap = require(\"../jsutils/keyMap.mjs\");\n\nvar _inspect = require(\"../jsutils/inspect.mjs\");\n\nvar _mapValue = require(\"../jsutils/mapValue.mjs\");\n\nvar _invariant = require(\"../jsutils/invariant.mjs\");\n\nvar _devAssert = require(\"../jsutils/devAssert.mjs\");\n\nvar _kinds = require(\"../language/kinds.mjs\");\n\nvar _predicates = require(\"../language/predicates.mjs\");\n\nvar _validate = require(\"../validation/validate.mjs\");\n\nvar _values = require(\"../execution/values.mjs\");\n\nvar _schema = require(\"../type/schema.mjs\");\n\nvar _scalars = require(\"../type/scalars.mjs\");\n\nvar _introspection = require(\"../type/introspection.mjs\");\n\nvar _directives = require(\"../type/directives.mjs\");\n\nvar _definition = require(\"../type/definition.mjs\");\n\nvar _valueFromAST = require(\"./valueFromAST.mjs\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nfunction extendSchema(schema, documentAST, options) {\n  (0, _schema.assertSchema)(schema);\n  documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    (0, _validate.assertValidSDLExtension)(documentAST, schema);\n  }\n\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\n\nfunction extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid; // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  var _iterator = _createForOfIteratorHelper(documentAST.definitions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var def = _step.value;\n\n      if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {\n        schemaDef = def;\n      } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {\n        schemaExtensions.push(def);\n      } else if ((0, _predicates.isTypeDefinitionNode)(def)) {\n        typeDefs.push(def);\n      } else if ((0, _predicates.isTypeExtensionNode)(def)) {\n        var extendedTypeName = def.name.value;\n        var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n        typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n      } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n        directiveDefs.push(def);\n      }\n    } // If this document contains no new types, extensions, or directives then\n    // return the same unmodified GraphQLSchema instance.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  var typeMap = Object.create(null);\n\n  var _iterator2 = _createForOfIteratorHelper(schemaConfig.types),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var existingType = _step2.value;\n      typeMap[existingType.name] = extendNamedType(existingType);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  for (var _i = 0, _typeDefs = typeDefs; _i < _typeDefs.length; _i++) {\n    var typeNode = _typeDefs[_i];\n\n    var _stdTypeMap$name;\n\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  var operationTypes = _objectSpread(_objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n\n  return _objectSpread(_objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {}, {\n    types: Object.values(typeMap),\n    directives: [].concat(_toConsumableArray(schemaConfig.directives.map(replaceDirective)), _toConsumableArray(directiveDefs.map(buildDirective))),\n    extensions: Object.create(null),\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if ((0, _definition.isListType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLList(replaceType(type.ofType));\n    }\n\n    if ((0, _definition.isNonNullType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      args: (0, _mapValue.mapValue)(config.args, extendArg)\n    }));\n  }\n\n  function extendNamedType(type) {\n    if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if ((0, _definition.isScalarType)(type)) {\n      return extendScalarType(type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      return extendObjectType(type);\n    }\n\n    if ((0, _definition.isInterfaceType)(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if ((0, _definition.isUnionType)(type)) {\n      return extendUnionType(type);\n    }\n\n    if ((0, _definition.isEnumType)(type)) {\n      return extendEnumType(type);\n    }\n\n    if ((0, _definition.isInputObjectType)(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n\n    false || (0, _invariant.invariant)(false, 'Unexpected type: ' + (0, _inspect.inspect)(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, (0, _mapValue.mapValue)(config.fields, function (field) {\n          return _objectSpread(_objectSpread({}, field), {}, {\n            type: replaceType(field.type)\n          });\n        })), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByURL = config.specifiedByURL;\n\n    var _iterator3 = _createForOfIteratorHelper(extensions),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var extensionNode = _step3.value;\n\n        var _getSpecifiedByURL;\n\n        specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return new _definition.GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {\n      specifiedByURL: specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(_toConsumableArray(type.getInterfaces().map(replaceNamedType)), _toConsumableArray(buildInterfaces(extensions)));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, (0, _mapValue.mapValue)(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(_toConsumableArray(type.getInterfaces().map(replaceNamedType)), _toConsumableArray(buildInterfaces(extensions)));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, (0, _mapValue.mapValue)(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {\n      types: function types() {\n        return [].concat(_toConsumableArray(type.getTypes().map(replaceNamedType)), _toConsumableArray(buildUnionTypes(extensions)));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread(_objectSpread({}, field), {}, {\n      type: replaceType(field.type),\n      args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread(_objectSpread({}, arg), {}, {\n      type: replaceType(arg.type)\n    });\n  }\n\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n\n    var _iterator4 = _createForOfIteratorHelper(nodes),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var node = _step4.value;\n\n        var _node$operationTypes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n        var operationTypesNodes =\n        /* c8 ignore next */\n        (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n        var _iterator5 = _createForOfIteratorHelper(operationTypesNodes),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var operationType = _step5.value;\n            // Note: While this could make early assertions to get the correctly\n            // typed values below, that would throw immediately while type system\n            // validation with validateSchema() will produce more actionable results.\n            // @ts-expect-error\n            opTypes[operationType.operation] = getNamedType(operationType.type);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === _kinds.Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === _kinds.Kind.NON_NULL_TYPE) {\n      return new _definition.GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new _directives.GraphQLDirective({\n      name: node.name.value,\n      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(function (_ref) {\n        var value = _ref.value;\n        return value;\n      }),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n\n    var _iterator6 = _createForOfIteratorHelper(nodes),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var node = _step6.value;\n\n        var _node$fields; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n        var nodeFields =\n        /* c8 ignore next */\n        (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n        var _iterator7 = _createForOfIteratorHelper(nodeFields),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var field = _step7.value;\n\n            var _field$description;\n\n            fieldConfigMap[field.name.value] = {\n              // Note: While this could make assertions to get the correctly typed\n              // value, that would throw immediately while type system validation\n              // with validateSchema() will produce more actionable results.\n              type: getWrappedType(field.type),\n              description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,\n              args: buildArgumentMap(field.arguments),\n              deprecationReason: getDeprecationReason(field),\n              astNode: field\n            };\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    var argsNodes =\n    /* c8 ignore next */\n    args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n\n    var _iterator8 = _createForOfIteratorHelper(argsNodes),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var arg = _step8.value;\n\n        var _arg$description; // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n\n\n        var type = getWrappedType(arg.type);\n        argConfigMap[arg.name.value] = {\n          type: type,\n          description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,\n          defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),\n          deprecationReason: getDeprecationReason(arg),\n          astNode: arg\n        };\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n\n    var _iterator9 = _createForOfIteratorHelper(nodes),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var node = _step9.value;\n\n        var _node$fields2; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n        var fieldsNodes =\n        /* c8 ignore next */\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n        var _iterator10 = _createForOfIteratorHelper(fieldsNodes),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var field = _step10.value;\n\n            var _field$description2; // Note: While this could make assertions to get the correctly typed\n            // value, that would throw immediately while type system validation\n            // with validateSchema() will produce more actionable results.\n\n\n            var type = getWrappedType(field.type);\n            inputFieldMap[field.name.value] = {\n              type: type,\n              description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,\n              defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),\n              deprecationReason: getDeprecationReason(field),\n              astNode: field\n            };\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n\n    var _iterator11 = _createForOfIteratorHelper(nodes),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var node = _step11.value;\n\n        var _node$values; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n\n        var valuesNodes =\n        /* c8 ignore next */\n        (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n        var _iterator12 = _createForOfIteratorHelper(valuesNodes),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var value = _step12.value;\n\n            var _value$description;\n\n            enumValueMap[value.name.value] = {\n              description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,\n              deprecationReason: getDeprecationReason(value),\n              astNode: value\n            };\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    function (node) {\n      var _node$interfaces$map, _node$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []\n      );\n    });\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    function (node) {\n      var _node$types$map, _node$types;\n\n      return (\n        /* c8 ignore next */\n        (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : []\n      );\n    });\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    var name = astNode.name.value;\n    var extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description;\n\n          var allNodes = [astNode].concat(_toConsumableArray(extensionASTNodes));\n          return new _definition.GraphQLObjectType({\n            name: name,\n            description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _astNode$description2;\n\n          var _allNodes = [astNode].concat(_toConsumableArray(extensionASTNodes));\n\n          return new _definition.GraphQLInterfaceType({\n            name: name,\n            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _astNode$description3;\n\n          var _allNodes2 = [astNode].concat(_toConsumableArray(extensionASTNodes));\n\n          return new _definition.GraphQLEnumType({\n            name: name,\n            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.UNION_TYPE_DEFINITION:\n        {\n          var _astNode$description4;\n\n          var _allNodes3 = [astNode].concat(_toConsumableArray(extensionASTNodes));\n\n          return new _definition.GraphQLUnionType({\n            name: name,\n            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _astNode$description5;\n\n          return new _definition.GraphQLScalarType({\n            name: name,\n            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,\n            specifiedByURL: getSpecifiedByURL(astNode),\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description6;\n\n          var _allNodes4 = [astNode].concat(_toConsumableArray(extensionASTNodes));\n\n          return new _definition.GraphQLInputObjectType({\n            name: name,\n            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n    }\n  }\n}\n\nvar stdTypeMap = (0, _keyMap.keyMap)([].concat(_toConsumableArray(_scalars.specifiedScalarTypes), _toConsumableArray(_introspection.introspectionTypes)), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\n\nfunction getSpecifiedByURL(node) {\n  var specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}"},"sourceMaps":null,"error":null,"hash":"0452c48c81afee9d7080dca41fedfe3d","cacheData":{"env":{}}}