{"id":"YXnQ","dependencies":[{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\package.json","includedInParent":true,"mtime":1640608262491},{"name":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\package.json","includedInParent":true,"mtime":1640596614331},{"name":"tslib","loc":{"line":1,"column":33},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useQuery.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\tslib\\tslib.es6.js"},{"name":"react","loc":{"line":2,"column":65},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useQuery.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\react\\index.js"},{"name":"@wry/equality","loc":{"line":3,"column":22},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useQuery.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@wry\\equality\\lib\\equality.esm.js"},{"name":"../context/index.js","loc":{"line":4,"column":33},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useQuery.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\context\\index.js"},{"name":"../../errors/index.js","loc":{"line":5,"column":28},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useQuery.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\errors\\index.js"},{"name":"../../core/index.js","loc":{"line":6,"column":31},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useQuery.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\core\\index.js"},{"name":"../parser/index.js","loc":{"line":7,"column":49},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useQuery.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\parser\\index.js"},{"name":"./useApolloClient.js","loc":{"line":8,"column":32},"parent":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useQuery.js","resolved":"C:\\Users\\pakev\\Desktop\\r_widgets\\react-widgets\\node_modules\\@apollo\\client\\react\\hooks\\useApolloClient.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useQuery = useQuery;\n\nvar _tslib = require(\"tslib\");\n\nvar _react = require(\"react\");\n\nvar _equality = require(\"@wry/equality\");\n\nvar _index = require(\"../context/index.js\");\n\nvar _index2 = require(\"../../errors/index.js\");\n\nvar _index3 = require(\"../../core/index.js\");\n\nvar _index4 = require(\"../parser/index.js\");\n\nvar _useApolloClient = require(\"./useApolloClient.js\");\n\nfunction useQuery(query, options) {\n  var _a;\n\n  var context = (0, _react.useContext)((0, _index.getApolloContext)());\n  var client = (0, _useApolloClient.useApolloClient)(options === null || options === void 0 ? void 0 : options.client);\n  (0, _index4.verifyDocumentType)(query, _index4.DocumentType.Query);\n\n  var _b = (0, _react.useState)(function () {\n    var watchQueryOptions = createWatchQueryOptions(query, options);\n    var obsQuery = null;\n\n    if (context.renderPromises) {\n      obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n    }\n\n    if (!obsQuery) {\n      obsQuery = client.watchQuery(watchQueryOptions);\n\n      if (context.renderPromises) {\n        context.renderPromises.registerSSRObservable(obsQuery, watchQueryOptions);\n      }\n    }\n\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && obsQuery.getCurrentResult().loading) {\n      context.renderPromises.addQueryPromise({\n        getOptions: function () {\n          return createWatchQueryOptions(query, options);\n        },\n        fetchData: function () {\n          return new Promise(function (resolve) {\n            var sub = obsQuery.subscribe({\n              next: function (result) {\n                if (!result.loading) {\n                  resolve();\n                  sub.unsubscribe();\n                }\n              },\n              error: function () {\n                resolve();\n                sub.unsubscribe();\n              },\n              complete: function () {\n                resolve();\n              }\n            });\n          });\n        }\n      }, function () {\n        return null;\n      });\n    }\n\n    return obsQuery;\n  }),\n      obsQuery = _b[0],\n      setObsQuery = _b[1];\n\n  var _c = (0, _react.useState)(function () {\n    var _a, _b;\n\n    var result = obsQuery.getCurrentResult();\n\n    if (!result.loading && options) {\n      if (result.error) {\n        (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n      } else if (result.data) {\n        (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n      }\n    }\n\n    return result;\n  }),\n      result = _c[0],\n      setResult = _c[1];\n\n  var ref = (0, _react.useRef)({\n    client: client,\n    query: query,\n    options: options,\n    result: result,\n    previousData: void 0,\n    watchQueryOptions: createWatchQueryOptions(query, options)\n  });\n  (0, _react.useEffect)(function () {\n    var _a, _b;\n\n    var watchQueryOptions = createWatchQueryOptions(query, options);\n    var nextResult;\n\n    if (ref.current.client !== client || !(0, _equality.equal)(ref.current.query, query)) {\n      var obsQuery_1 = client.watchQuery(watchQueryOptions);\n      setObsQuery(obsQuery_1);\n      nextResult = obsQuery_1.getCurrentResult();\n    } else if (!(0, _equality.equal)(ref.current.watchQueryOptions, watchQueryOptions)) {\n      obsQuery.setOptions(watchQueryOptions).catch(function () {});\n      nextResult = obsQuery.getCurrentResult();\n      ref.current.watchQueryOptions = watchQueryOptions;\n    }\n\n    if (nextResult) {\n      var previousResult = ref.current.result;\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = nextResult);\n\n      if (!nextResult.loading && options) {\n        if (!result.loading) {\n          if (result.error) {\n            (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n          } else if (result.data) {\n            (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n          }\n        }\n      }\n    }\n\n    Object.assign(ref.current, {\n      client: client,\n      query: query\n    });\n  }, [obsQuery, client, query, options]);\n  (0, _react.useEffect)(function () {\n    if (context.renderPromises) {\n      return;\n    }\n\n    var subscription = obsQuery.subscribe(onNext, onError);\n\n    function onNext() {\n      var _a, _b;\n\n      var previousResult = ref.current.result;\n      var result = obsQuery.getCurrentResult();\n\n      if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && (0, _equality.equal)(previousResult.data, result.data)) {\n        return;\n      }\n\n      if (previousResult.data) {\n        ref.current.previousData = previousResult.data;\n      }\n\n      setResult(ref.current.result = result);\n\n      if (!result.loading) {\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, result.data);\n      }\n    }\n\n    function onError(error) {\n      var _a, _b;\n\n      var last = obsQuery[\"last\"];\n      subscription.unsubscribe();\n\n      try {\n        obsQuery.resetLastResults();\n        subscription = obsQuery.subscribe(onNext, onError);\n      } finally {\n        obsQuery[\"last\"] = last;\n      }\n\n      if (!error.hasOwnProperty('graphQLErrors')) {\n        throw error;\n      }\n\n      var previousResult = ref.current.result;\n\n      if (previousResult && previousResult.loading || !(0, _equality.equal)(error, previousResult.error)) {\n        setResult(ref.current.result = {\n          data: previousResult.data,\n          error: error,\n          loading: false,\n          networkStatus: _index3.NetworkStatus.error\n        });\n        (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n      }\n    }\n\n    return function () {\n      return subscription.unsubscribe();\n    };\n  }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n  var partial;\n  _a = result, partial = _a.partial, result = (0, _tslib.__rest)(_a, [\"partial\"]);\n  {\n    if (partial && (options === null || options === void 0 ? void 0 : options.partialRefetch) && !result.loading && (!result.data || Object.keys(result.data).length === 0) && obsQuery.options.fetchPolicy !== 'cache-only') {\n      result = (0, _tslib.__assign)((0, _tslib.__assign)({}, result), {\n        loading: true,\n        networkStatus: _index3.NetworkStatus.refetch\n      });\n      obsQuery.refetch();\n    }\n\n    if (context.renderPromises && (options === null || options === void 0 ? void 0 : options.ssr) !== false && !(options === null || options === void 0 ? void 0 : options.skip) && result.loading) {\n      obsQuery.setOptions(createWatchQueryOptions(query, options)).catch(function () {});\n    }\n\n    Object.assign(ref.current, {\n      options: options\n    });\n  }\n\n  if ((context.renderPromises || client.disableNetworkFetches) && (options === null || options === void 0 ? void 0 : options.ssr) === false) {\n    result = ref.current.result = {\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: _index3.NetworkStatus.loading\n    };\n  } else if ((options === null || options === void 0 ? void 0 : options.skip) || (options === null || options === void 0 ? void 0 : options.fetchPolicy) === 'standby') {\n    result = {\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: _index3.NetworkStatus.ready\n    };\n  }\n\n  if (result.errors && result.errors.length) {\n    result = (0, _tslib.__assign)((0, _tslib.__assign)({}, result), {\n      error: result.error || new _index2.ApolloError({\n        graphQLErrors: result.errors\n      })\n    });\n  }\n\n  var obsQueryFields = (0, _react.useMemo)(function () {\n    return {\n      refetch: obsQuery.refetch.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n    };\n  }, [obsQuery]);\n  return (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, obsQueryFields), {\n    variables: createWatchQueryOptions(query, options).variables,\n    client: client,\n    called: true,\n    previousData: ref.current.previousData\n  }), result);\n}\n\nfunction createWatchQueryOptions(query, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var skip = options.skip,\n      ssr = options.ssr,\n      onCompleted = options.onCompleted,\n      onError = options.onError,\n      displayName = options.displayName,\n      watchQueryOptions = (0, _tslib.__rest)(options, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"displayName\"]);\n\n  if (skip) {\n    watchQueryOptions.fetchPolicy = 'standby';\n  } else if (((_a = watchQueryOptions.context) === null || _a === void 0 ? void 0 : _a.renderPromises) && (watchQueryOptions.fetchPolicy === 'network-only' || watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  } else if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = 'cache-first';\n  }\n\n  if (!watchQueryOptions.variables) {\n    watchQueryOptions.variables = {};\n  }\n\n  return (0, _tslib.__assign)({\n    query: query\n  }, watchQueryOptions);\n}"},"sourceMaps":null,"error":null,"hash":"f741a3d7d7e563667707fb077fd050dd","cacheData":{"env":{}}}